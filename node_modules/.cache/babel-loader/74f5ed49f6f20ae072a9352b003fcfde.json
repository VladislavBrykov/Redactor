{"ast":null,"code":"if (process.fiberLib) {\n  module.exports = process.fiberLib;\n} else {\n  var fs = require('fs'),\n      path = require('path'),\n      detectLibc = require('detect-libc'); // Seed random numbers [gh-82]\n\n\n  Math.random(); // Look for binary for this platform\n\n  var modPath = path.join(__dirname, 'bin', process.platform + '-' + process.arch + '-' + process.versions.modules + (process.platform === 'linux' ? '-' + detectLibc.family : ''), 'fibers');\n\n  try {\n    // Pull in fibers implementation\n    process.fiberLib = module.exports = require(modPath).Fiber;\n  } catch (ex) {\n    // No binary!\n    console.error('## There is an issue with `node-fibers` ##\\n' + '`' + modPath + '.node` is missing.\\n\\n' + 'Try running this to fix the issue: ' + process.execPath + ' ' + __dirname.replace(' ', '\\\\ ') + '/build');\n    console.error(ex.stack || ex.message || ex);\n    throw new Error('Missing binary. See message above.');\n  }\n\n  setupAsyncHacks(module.exports);\n}\n\nfunction setupAsyncHacks(Fiber) {\n  // Older (or newer?) versions of node may not support this API\n  try {\n    var getAndClearStack = function getAndClearStack() {\n      var ii = getAsyncIdStackSize();\n      var stack = new Array(ii);\n\n      for (; ii > 0; --ii) {\n        var asyncId = asyncIds[kExecutionAsyncId];\n        stack[ii - 1] = {\n          asyncId: asyncId,\n          triggerId: asyncIds[kTriggerAsyncId]\n        };\n        popAsyncContext(asyncId);\n      }\n\n      return stack;\n    };\n\n    var restoreStack = function restoreStack(stack) {\n      for (var ii = 0; ii < stack.length; ++ii) {\n        pushAsyncContext(stack[ii].asyncId, stack[ii].triggerId);\n      }\n    };\n\n    var wrapFunction = function wrapFunction(fn) {\n      return function () {\n        var stack = getAndClearStack();\n\n        try {\n          return fn.apply(this, arguments);\n        } finally {\n          restoreStack(stack);\n        }\n      };\n    }; // Monkey patch methods which may long jump\n\n\n    var aw = process.binding('async_wrap');\n    var getAsyncIdStackSize;\n\n    if (aw.asyncIdStackSize instanceof Function) {\n      getAsyncIdStackSize = aw.asyncIdStackSize;\n    } else if (aw.constants.kStackLength !== undefined) {\n      getAsyncIdStackSize = function (kStackLength) {\n        return function () {\n          return aw.async_hook_fields[kStackLength];\n        };\n      }(aw.constants.kStackLength);\n    } else {\n      throw new Error('Couldn\\'t figure out how to get async stack size');\n    }\n\n    var popAsyncContext = aw.popAsyncContext || aw.popAsyncIds;\n    var pushAsyncContext = aw.pushAsyncContext || aw.pushAsyncIds;\n\n    if (!popAsyncContext || !pushAsyncContext) {\n      throw new Error('Push/pop do not exist');\n    }\n\n    var kExecutionAsyncId;\n\n    if (aw.constants.kExecutionAsyncId === undefined) {\n      kExecutionAsyncId = aw.constants.kCurrentAsyncId;\n    } else {\n      kExecutionAsyncId = aw.constants.kExecutionAsyncId;\n    }\n\n    var kTriggerAsyncId;\n\n    if (aw.constants.kTriggerAsyncId === undefined) {\n      kTriggerAsyncId = aw.constants.kCurrentTriggerId;\n    } else {\n      kTriggerAsyncId = aw.constants.kTriggerAsyncId;\n    }\n\n    var asyncIds = aw.async_id_fields || aw.async_uid_fields;\n    Fiber.yield = wrapFunction(Fiber.yield);\n    Fiber.prototype.run = wrapFunction(Fiber.prototype.run);\n    Fiber.prototype.throwInto = wrapFunction(Fiber.prototype.throwInto);\n  } catch (err) {\n    return;\n  }\n}","map":{"version":3,"sources":["/Users/vladislav/node_modules/fibers/fibers.js"],"names":["process","fiberLib","module","exports","fs","require","path","detectLibc","Math","random","modPath","join","__dirname","platform","arch","versions","modules","family","Fiber","ex","console","error","execPath","replace","stack","message","Error","setupAsyncHacks","getAndClearStack","ii","getAsyncIdStackSize","Array","asyncId","asyncIds","kExecutionAsyncId","triggerId","kTriggerAsyncId","popAsyncContext","restoreStack","length","pushAsyncContext","wrapFunction","fn","apply","arguments","aw","binding","asyncIdStackSize","Function","constants","kStackLength","undefined","async_hook_fields","popAsyncIds","pushAsyncIds","kCurrentAsyncId","kCurrentTriggerId","async_id_fields","async_uid_fields","yield","prototype","run","throwInto","err"],"mappings":"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","sourcesContent":["if (process.fiberLib) {\n\tmodule.exports = process.fiberLib;\n} else {\n\tvar fs = require('fs'), path = require('path'), detectLibc = require('detect-libc');\n\n\t// Seed random numbers [gh-82]\n\tMath.random();\n\n\t// Look for binary for this platform\n\tvar modPath = path.join(__dirname, 'bin', process.platform+ '-'+ process.arch+ '-'+ process.versions.modules+\n\t\t((process.platform === 'linux') ? '-'+ detectLibc.family : ''), 'fibers');\n\ttry {\n\t\t// Pull in fibers implementation\n\t\tprocess.fiberLib = module.exports = require(modPath).Fiber;\n\t} catch (ex) {\n\t\t// No binary!\n\t\tconsole.error(\n\t\t\t'## There is an issue with `node-fibers` ##\\n'+\n\t\t\t'`'+ modPath+ '.node` is missing.\\n\\n'+\n\t\t\t'Try running this to fix the issue: '+ process.execPath+ ' '+ __dirname.replace(' ', '\\\\ ')+ '/build'\n\t\t);\n\t\tconsole.error(ex.stack || ex.message || ex);\n\t\tthrow new Error('Missing binary. See message above.');\n\t}\n\n\tsetupAsyncHacks(module.exports);\n}\n\nfunction setupAsyncHacks(Fiber) {\n\t// Older (or newer?) versions of node may not support this API\n\ttry {\n\t\tvar aw = process.binding('async_wrap');\n\t\tvar getAsyncIdStackSize;\n\n\t\tif (aw.asyncIdStackSize instanceof Function) {\n\t\t\tgetAsyncIdStackSize = aw.asyncIdStackSize;\n\t\t} else if (aw.constants.kStackLength !== undefined) {\n\t\t\tgetAsyncIdStackSize = function(kStackLength) {\n\t\t\t\treturn function() {\n\t\t\t\t\treturn aw.async_hook_fields[kStackLength];\n\t\t\t\t};\n\t\t\t}(aw.constants.kStackLength);\n\t\t} else {\n\t\t\tthrow new Error('Couldn\\'t figure out how to get async stack size');\n\t\t}\n\n\t\tvar popAsyncContext = aw.popAsyncContext || aw.popAsyncIds;\n\t\tvar pushAsyncContext = aw.pushAsyncContext || aw.pushAsyncIds;\n\t\tif (!popAsyncContext || !pushAsyncContext) {\n\t\t\tthrow new Error('Push/pop do not exist');\n\t\t}\n\n\t\tvar kExecutionAsyncId;\n\t\tif (aw.constants.kExecutionAsyncId === undefined) {\n\t\t\tkExecutionAsyncId = aw.constants.kCurrentAsyncId;\n\t\t} else {\n\t\t\tkExecutionAsyncId = aw.constants.kExecutionAsyncId;\n\t\t}\n\t\tvar kTriggerAsyncId;\n\t\tif (aw.constants.kTriggerAsyncId === undefined) {\n\t\t\tkTriggerAsyncId = aw.constants.kCurrentTriggerId;\n\t\t} else {\n\t\t\tkTriggerAsyncId = aw.constants.kTriggerAsyncId;\n\t\t}\n\n\t\tvar asyncIds = aw.async_id_fields || aw.async_uid_fields;\n\n\t\tfunction getAndClearStack() {\n\t\t\tvar ii = getAsyncIdStackSize();\n\t\t\tvar stack = new Array(ii);\n\t\t\tfor (; ii > 0; --ii) {\n\t\t\t\tvar asyncId = asyncIds[kExecutionAsyncId];\n\t\t\t\tstack[ii - 1] = {\n\t\t\t\t\tasyncId: asyncId,\n\t\t\t\t\ttriggerId: asyncIds[kTriggerAsyncId],\n\t\t\t\t};\n\t\t\t\tpopAsyncContext(asyncId);\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\n\t\tfunction restoreStack(stack) {\n\t\t\tfor (var ii = 0; ii < stack.length; ++ii) {\n\t\t\t\tpushAsyncContext(stack[ii].asyncId, stack[ii].triggerId);\n\t\t\t}\n\t\t}\n\n\t\tfunction wrapFunction(fn) {\n\t\t\treturn function() {\n\t\t\t\tvar stack = getAndClearStack();\n\t\t\t\ttry {\n\t\t\t\t\treturn fn.apply(this, arguments);\n\t\t\t\t} finally {\n\t\t\t\t\trestoreStack(stack);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Monkey patch methods which may long jump\n\t\tFiber.yield = wrapFunction(Fiber.yield);\n\t\tFiber.prototype.run = wrapFunction(Fiber.prototype.run);\n\t\tFiber.prototype.throwInto = wrapFunction(Fiber.prototype.throwInto);\n\n\t} catch (err) {\n\t\treturn;\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}